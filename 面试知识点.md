# 面试知识点

## WebServer

### 1.守护进程

//查看守护进程

ps -ef |grep ‘server’

守护进程创建步骤

1.fork（） 父进程退出

2.setsid（） 使子进程独立

3.fork（） 父进程退出 使进程不再是首会话来禁止进程重新打开中断

4.chdir（） 让根目录成为子进程工作目录

5.close（fd 1 2 3） 关闭标准输入输出报错3个文件描述符

6.umask（） 将权限全部开放

7.处理SIGCHID 避免僵尸进程（1.直接忽略 2.注册信号处理函数 用waitpid回收）

###2.Reactor是什么?

 Reactor模式是处理并发I/O比较常见的一种模式，中心思想就是，将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程阻塞在多路复用器上；一旦有I/O事件到来或是准备就绪(区别在于多路复用器是边沿触发还是水平触发)，多路复用器返回并将相应I/O事件分发到对应的处理器中。

具体流程：

1.主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。

2.主线程调用 epoll_wait 等待 socket 上有数据可读。

3.当 socket 上有数据可读时， epoll_wait 通知主线程。主线程将读事件分发给对应的工作线程处理

4.对应的工作线程从 socket 读取数据，并处理客户请求，向epoll内核事件表中注册该 socket 上的写就绪事件。

5.当主线程调用 epoll_wait 等待 socket 可写。

6.当 socket 可写时，epoll_wait 通知主线程。主线程将写事件分发给对应的工作线程处理

### 3.Proactor是什么？跟Reactor的区别？

 Proactor最大的特点是使用异步I/O。所有的I/O操作都交由系统提供的异步I/O接口去执行。工作线程仅仅负责业务逻辑。 

具体流程：

1.主线程调用异步IO读函数，向epoll 内核事件表中注册 socket 上的读完成事件。并告知内核用户缓冲区的位置，以及读操作完成时如何通知应用程序

2.主线程继续处理其他逻辑

3.主线程收到IO读完成的通知，主线程将事件分发给对应的工作线程

4.工作线程处理逻辑，完成后调用异步IO写函数，向epoll 内核事件表中注册 socket 上的写完成事件

5.主线程继续处理其他逻辑

6.主线程收到IO写完成的通知，主线程将事件分发给对应的工作线程作善后处理，如关闭socket等

### 4.同步I/O模拟Proactor

原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。

具体流程：

1.主线程往 epoll 内核事件表中注册 socket上的读就绪事件。

2.主线程调用 epoll_wait 等待 socket 上有数据可读。

3.当 socket 上有数据可读时， epoll_wait 通知主线程。主线程读取数据，然后将读取完的数据交由工作线程处理

4.工作线程处理客户请求，然后往 epoll内核事件表中注册该 socket 上的写就绪事件。

5.当主线程调用 epoll_wait 等待 socket 可写。

6.当 socket 可写时，epoll_wait 通知主线程。主线程向socket上写入处理结果。

### 5.阻塞和非阻塞

阻塞和非阻塞是针对于**进程**在访问数据的时候，根据IO操作的就绪状态来采取的不同方式。

如果数据没有准备好：

阻塞方式下，读取或者写入函数将一直等待

非阻塞方式下，读取或者写入函数会立即返回一个状态值

### 6.同步和异步

同步和异步是针对**应用程序和内核**的交互而言的

同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪

异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知

### 7.五种网络I/O模型

1.阻塞I/O

2.非阻塞I/O

**3.I/O多路复用**

​	IO多路复用使用两个系统调用（select/poll/epoll和recvfrom），blocking IO只调用了recvfrom。select/poll/epoll核心是可以同时处理多个connection，而不是更快，所以连接数不高的话，性能不一定比多线程+阻塞IO好。  使用select可以避免同步非阻塞IO中轮询等待问题。

​	IO多路复用同一个线程同时处理多个IO请求 ，而在同步阻塞模型中，必须通过多线程方式才能达到这个目的。所以IO多路复用设计目的其实不是为了快，而是为了解决线程/进程数量过多对服务器开销造成的压力。

4.信号驱动I/O

5.异步I/O

### 8.epoll的两种工作模式

1.LT 水平触发

一个文件事件就绪之后，每次调用epoll_wait都会通知（水平触发）

2.ET 边缘触发

边缘触发就是只触发一次，下次调用epoll_wait的时候就不通知了，边缘触发只支持非阻塞socket。

### 9.有限状态机有哪几种状态？

1.主状态机

​	主状态机的三种可能状态，分别表示：
​		当前正在分析请求行：CHECK_STATE_REQUESTLINE
​		当前正在分析头部字段：CHECK_STATE_HEADER
 		当前正在解析请求体：CHECK_STATE_CONTENT 

2.从状态机

​	从状态机的三种可能状态，即行的读取状态，分别表示：
​		读取到一个完整的行：LINE_OK
​		行出错：LINE_BAD
​		行数据尚且不完整：LINE_OPEN 

3.服务器状态

​	服务器处理HTTP请求的可能结果，报文解析的结果:
​		表示请求不完整，需要继续读取客户数据：NO_REQUEST
​		表示获得了一个完整的客户请求：GET_REQUEST
​		表示客户请求有语法错误：BAD_REQUEST
​		表示客户对资源没有足够的访问权限：FORBINNEN_REQUEST
​		表示服务器内部错误：INTERNAL_ERROR
​		表示客户端已经关闭连接了：CLOSED_CONNECTION

### 10.介绍项目实现流程

**1.写lock.h **

有3个class

①class locker 互斥锁

②class sem 信号量 用于线程池 工作队列插入任务时post（），run函数中调用wait消费工作队列

③class cond 条件变量 用于异步日志的阻塞队列

**2.写threadpool.h**

①pthread_t *m_threads 描述线程池的数组

②List<T*> work_queue 一个工作队列 用来插入http请求工作对象

③信号量sem 工作队列是否有任务需要处理实现通信

④互斥锁locker 用于保护请求队列实现同步

⑤线程池的数量如何选择 ？CPU核心数*（1+IO时间/线程CPU时间）

**3.写http_coon.h**

①static epoll_fd 

②功能函数 process read write等

**4.main（）函数**

①创建线程池

②创建socket 、设置端口复用setsockopt、sockaddr_in：IP_ANY和port、bind（）socket、listen（）socket 

③创建epoll 监听listenfd 

④调用epoll_wait 监听所有socket

⑤处理epoll_wait返回结果：

*1.sockfd==listenfd //新的客户端连接    调用accept（）接受新连接（sockaddr_in 存储客户端IP和port）客户端数组中初始化新连接的客户端对象*

*2.events[i].events & EPOLLIN 读事件*

*3.events[i].events & EPOLLOUT 写事件*

*4.events[i].events & (EPOLLRDHUP | EPOLLHUP | EPOLLERR) EPOLLRDHUP EPOLLHUP检测出错/EPOLLERR服务器出错 关闭连接*



## 计算机网络

### 1.TCP/IP协议

### 2.TCP三次握手

![1650568689445](C:\Users\qiqua\AppData\Roaming\Typora\typora-user-images\1650568689445.png)



### 3.WHY 三次握手？

①防止旧的重复连接初始化造成混乱。三次握手则可以在客户端准备发送第三次报文时，客户端有足够的上下文判断当前连接是否是历史连接。如果是历史连接（序列号过期或超时），则第三次握手发送RST报文，终止该历史连接。如果不是历史连接，则发送ACK报文。

②同步双方初始序列号。序列号能保证数据包不重复、不丢弃、按序传输。

③避免资源浪费。避免重复的SYN建立重复的连接而造成资源浪费。

### Linux内核SYN队列和Accept队列

①服务端接收到客户端SYN报文，会将其加入到SYN队列

②接着发送SYN+ACK报文，等待客户端回应ACK报文

③服务端收到ACK报文后，从SYN队列移除放入Accept队列

④应用调用accept（）接口，从Accept队列中取出连接

### 4.TCP四次挥手

![1650568709848](C:\Users\qiqua\AppData\Roaming\Typora\typora-user-images\1650568709848.png)

![1650599639738](C:\Users\qiqua\AppData\Roaming\Typora\typora-user-images\1650599639738.png)



###5.WHY TIME_WAIT？

①防止具有相同四元组的旧数据包被收到

②保证被动关闭连接的一方能被正确的关闭

**危害：**

①占用系统资源

②占用端口资源

####WHY 2MSL

服务器等待最后ACK超时重传最大时间为1MSL，服务器重发到客户端的FIN的最大时间也为1MSL，故为2MSL

###6.WHY 四次挥手？

服务器通常需要等待数据的发送和处理完成，所以服务器的ACK和FIN一般都会分开发送。

### 7.TCP保证可靠性的手段

####序列号机制

序列号能保证数据包不重复、不丢弃、按序传输。

#### 超时重传

发送数据超过指定的时间后，如果没有收到对方的ACK确认应答报文，就会重发该数据。

RTT：报文往返时间

RTO：超时重传时间

MSL：报文最大生存时间

MSS：报文最大段长度

RTO应略大于RTT，过大的话效率低下，过小的话会增加网络堵塞，因为数据可能并没有丢失，只是还没到达。

####快速重传

当收到三个相同的ACK报文时，会在RTO过期之前，重传丢失的报文段。

#### 滑动窗口

解决的问题：即使在RTT较长的情况下，也不会降低网络通信的效率。解决了网络延迟导致的通信效率低下的问题

窗口大小：指无需等待确认应答，而可以继续发送数据的最大值。TCP头里有一个字段叫Window，表示窗口大小

#### 流量控制

目的：避免发送方的数据填满接收方的缓存

手段：滑动窗口

窗口死锁怎么解决：发送方定时发送探测报文，探测接收方窗口是否还是0

#### 拥塞控制

目的：避免发送方的数据填满整个网络

手段：拥塞窗口。cwnd，发送方维护的一个状态变量，会根据网络的拥塞程度动态变化。

拥塞控制算法：

①慢启动。发送方每收到一个ACK，窗口大小就会+1。发包个数指数上升。

​	慢启动门限：控制慢启动涨到多少，一般为65535字节。当窗口大小到达慢启动门限时，就会进入拥塞避免。

②拥塞避免。每收到一个ACK时，cwnd增加1/cwnd。线性增长。

​	当触发超时重传，进入拥塞发生。

③拥塞发生。触发条件：触发超时重传机制。

​	规则：进入慢启动，慢启动门限设为cwnd/2，cwnd设为1。

④快速恢复。出发条件：触发快速重传机制。快速恢复算法认为，你还能收到3个相同的ACK，说明网络不是那么糟糕，所以没有像超时重传那么强烈。

​	规则：慢启动门限设为cwnd/2，cdnd=cwnd/2，进入拥塞避免，也就是线性增长。（cwnd可+3）

###8.TCP和UDP的区别

TCP是面向连接的，在传输前需要三次握手建立连接，TCP是有连接的可靠传输

UDP是无连接的，即刻传输数据，UDP是无连接的不可靠传输

服务形式的区别：TCP点对点，UDP支持一对一、一对多、多对多。

传输方式的区别：TCP基于字节流，没有边界，但是保证传输顺序和可靠性；UDP基于数据包，有边界。

适用场景的区别：TCP适用保证数据正确传输的应用：如发送邮件、上传文件等；UDP适用需要一定的实时性但又对数据的完整性要求没那么高的应用：如直播、语音电话等。

TCP可靠性如何保证。见上。

### 9.TCP/IP四层模型

**应用层**：为进程提供服务，如HTTP协议、FTP协议等。

**传输层**：传输层负责端到端的通信，如TCP、UDP等。

**网络层**： 网络层负责网络包的封装、分片、路由、转发，如IP、ICMP等。

**网络接口层**： 网络接口层负责包在物理网络中的传输，如网络包的封帧、MAC寻址、差错检测、网卡传输网络帧等。网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路 

### 10.OSI七层模型

**应用层**：为进程提供服务，如HTTP协议、FTP协议等

**表示层**：不同的机器采取的编码方式，可能使用的数据结构也不同，表示层就是对这些数据进行翻译，使用标准的编码方式，另外还可以对分组进行数据压缩

**会话层**：主要是系统之间建立会话请求，通过传输层提供的端到端的服务，进一步有序的传递数据，主要就是对会话同步，包括说建立、管理、终止进程之间的会话

**传输层**：传输层负责端到端的通信，如TCP、UDP等。

**网络层**： 网络层负责网络包的封装、分片、路由、转发，如IP、ICMP等。

**数据链路层**：接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。主要功能是通过各种控制协议，使有差错的物理线路变为无差错的数据链路。

**物理层**：主要解决两台物理机之间的通信，通过二进制比特流的传输来实现。

### 11.HTTP与HTTPS

**HTTP是超文本传输协议**

无状态：HTTP是基于TCP连接的一种无状态协议，这里的无状态是指http协议不会记录用户的数据，建立连接和传输都是独立的过程

明文传输：传输的过程没有经过加密，都是明文传输。为调试工作带来了便利性，但信息透明，容易被窃取

不安全：明文传输（数据泄露）、不验证通信方的身份、无法验证报文的完整性

HTTP具体传输过程就是客户端建立tcp连接，然后发送一个请求给服务端，格式为：一个URL，协议版本号，然后就是请求头和请求体的信息

服务端接收到请求之后，执行相应的逻辑，然后返回一个response。

**HTTPS是超文本安全传输协议**

HTTPS解决了HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了ssl/tls安全协议，使得报文能够加密传输。

HTTPS在TCP三次握手之后，还需进行ssl/tls的握手过程，才可进入加密报文传输。

优点：信息加密（保护数据不泄露）、身份证书（证明报文的完整性）

加密方式：对称加密、非对称加密、混合加密

HTTPS：混合加密。通信建立前、非对称加密；通信过程中、对称加密

### 12.HTTP请求

HTTP请求报文：

​	请求行：请求方法+url+协议版本号

​	请求头：key+value

​	请求体：

HTTP响应报文：

​	响应行：协议版本+状态码+状态码描述

​	响应头：

​	响应体：

**常见HTTP状态码：**

​	1xx：表示还需要后续操作

​	2xx：表示报文被正确处理

​	3xx：重定向，资源位置发生变动，需要客户端重新发送请求

​	4xx：表示客户端错误，请求报文有误

​	5xx：表示服务器错误

### 13.浏览器输入url到显示界面的整个过程

1.输入url，首先会查询浏览器缓存->系统缓存->路由器缓存有没有该dns解析的域名，如果有就直接用，如果没有就回去调用DNS域名解析服务(这相当于也是发起一次查询)。然后就会去使用DNS解析协议解析该域名，并且获取到IP地址。

2.然后浏览器就会根据这个IP地址和默认的端口号80端口去发起一个请求，由应用层下发到传输层，传输层开始建立TCP连接，进行TCP三次握手。TCP 协议会指定源端口号和目的端口号，源端口由浏览器默认随机。

3.三次握手之后，TCP开始传输数据请求，传输层将报文封装成为报文段，下发到网络层。

4.网络层将传输层发过来的报文封装成IP数据包，将本机地址作为源地址，获取的 IP 地址作为目的地址。然后下发给数据链路层。

5.数据链路层将ip数据包封装成一个个的帧，还需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，服务器的MAC地址作为目标地址。

6.物理层传输。

7.服务器收到该帧，然后不停的解析，解析出请求上交给应用层，服务器收到该请求，然后返回响应的数据。

8.数据传输完成之后，TCP通过四次挥手连接释放。

9.浏览器解析html并显示。

### 14.HTTP1.0 1.1 2.0 3.0

HTTP1.1新特性：

①默认长连接

②管线化：客户端可以同时发送多个HTTP请求，不用等待响应（可以并行传输请求，但是并不是真正的并行，顺序不能打乱，并且服务端处理请求的数据也不能乱）

③断点续传

HTTP2.0新特性：

①传输格式变化，采用了新的二进制格式（HTTP1.x的解析都是基于文本，HTTP2.0只认0/1组合）

②多路复用：一个请求对应一个ID，每个连接可以有多个请求。

③header压缩：1.x中header带有大量信息且每次都要重复发送，2.0中通讯双方各自缓存一份header字段表。

如何实现的多路复用：**通过帧对数据进行了顺序标识（不同的请求有不同的流id），这样收到数据之后可以按照序列对数据进行合并（同一个帧称为一个消息），就是因为有了序列，所以才能并行的传输数据**。

HTTP3.0新特性：

①使用UDP协议

### 15.为什么ET模式的eopll监听的socket要设置为非阻塞

我们应该使用非阻塞的socket：当文件描述符准备就绪的时候，需要一次性把数据读完，如果socket为阻塞，则最后一次读写后线程会阻塞。

### 16.Socket

### ![1650598981650](C:\Users\qiqua\AppData\Roaming\Typora\typora-user-images\1650598981650.png)



![1650599108189](C:\Users\qiqua\AppData\Roaming\Typora\typora-user-images\1650599108189.png)





## 操作系统

### 进程间通信的方式

①管道（匿名管道、有名管道FIFO）

②信号

③消息队列

④内存映射

⑤共享内存

⑥信号量

⑦socket

### 内存管理



### 死锁

###互斥和同步有什么方法

### 堆栈的区别

①申请方式：栈由系统自动分配，堆是人为申请开辟

②申请大小：栈获得的空间较小，而堆获得的空间较大

③申请效率：栈由系统分配，速度较快，而堆一般速度较慢

④底层不同：栈是连续的空间，堆是不连续的空间

## MySQL

### 索引

### 事务

### 锁机制

### 三大范式

第一范式： 用来确保每列的原子性，要求每列（或者每个属性值）都是不可再分的最小数据单元（也称为最小的原子单元） 

第二范式： 如果一个表满足第一范式，并且除了主键以外的其他列全部都依赖于该主键，那么该表满足第二范式。

第三范式： 如果一个关系满足第二范式，并且除了主键以外的其他列都依赖于主键列，列和列之间不存在相互依赖关系，则满足第三范式。 





